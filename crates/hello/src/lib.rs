#![feature(once_cell)] // 1.53.0-nightly (2021-04-01 d474075a8f28ae9a410e)
use crate::nes::cpu::Mem;
use crate::nes::cpu::{read_screen_state, render_screen};
use kurbo::*;
use piet::*;
use piet_web::*;
use rand::Rng;
use std::{lazy::SyncLazy, sync::Mutex};
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{window, CanvasRenderingContext2d};

// use std::time::Duration;
// use wasm_timer::sleep;

use gloo_events::EventListener;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

static CPU: SyncLazy<Mutex<nes::cpu::CPU>> = SyncLazy::new(|| Mutex::new(nes::cpu::CPU::new()));

// Import the `window.alert` function from the Web.
#[wasm_bindgen]
extern "C" {
  fn alert(s: &str);
  // Use `js_namespace` here to bind `console.log(..)` instead of just
  // `log(..)`
  #[wasm_bindgen(js_namespace = console)]
  fn log(s: &str);
}

macro_rules! console_log {
	// Note that this is using the `log` function imported above during
	// `bare_bones`
	($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

fn request_animation_frame(f: &Closure<dyn FnMut()>) {
  window()
    .unwrap()
    .request_animation_frame(f.as_ref().unchecked_ref())
    .expect("should register `requestAnimationFrame` OK");
}

#[wasm_bindgen]
pub fn make_nes(canvas_id: &str) -> Result<(), JsValue> {
  let mut cpu = CPU.lock().unwrap();
  cpu.reset();

  let game_code = vec![
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
    0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
    0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
    0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
    0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
    0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
    0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
    0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
    0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
    0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
    0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
    0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
    0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
    0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
    0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
    0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
    0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
    0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa6, 0xff, 0xea,
    0xea, 0xca, 0xd0, 0xfb, 0x60,
  ];

  cpu.load(game_code);

  // get canvas and webgl context
  let window = window().unwrap();
  let document = web_sys::window().unwrap().document().unwrap();
  let wasm_div = document.get_element_by_id("wasm").unwrap();
  let canvas = document.get_element_by_id(canvas_id).unwrap();
  let canvas: web_sys::HtmlCanvasElement = canvas.dyn_into::<web_sys::HtmlCanvasElement>()?;

  let context = canvas
    .get_context("2d")?
    .unwrap()
    .dyn_into::<CanvasRenderingContext2d>()?;

  let mut rc = WebRenderContext::new(context, window);

  // let whole_board = Rect::new(0., 0., 32 as f64, 32 as f64);
  // rc.clear(whole_board, Color::rgb8(0xf4,0xf4,0xf4));

  // 32 cols with 3bytes per point, and 32 rows
  let mut screen_state = [0 as u8; 32 * 3 * 32];

  // map screen with above 32x32
  let mut cscr = Rect::new(0., 0., 320.0, 320.0);
  // clear above
  rc.clear(cscr, Color::rgb8(0xff, 0xff, 0xff));

  let mut rng = rand::thread_rng();

  // keyboard event??
  let on_keydown = EventListener::new(&canvas, "keydown", move |event| {
    let keyboard_event = event.clone().dyn_into::<web_sys::KeyboardEvent>().unwrap();
    let mut event_string = String::from("");
    event_string.push_str(&event.type_());
    event_string.push_str(&" : ");
    event_string.push_str(&keyboard_event.key());

    unsafe {
      console_log!("key event, {}", event_string);
    }
  });
  on_keydown.forget();

  // keyboard event??
  let on_keyup = EventListener::new(&canvas, "keyup", move |event| {
    let keyboard_event = event.clone().dyn_into::<web_sys::KeyboardEvent>().unwrap();
    let mut event_string = String::from("");
    event_string.push_str(&event.type_());
    event_string.push_str(&" : ");
    event_string.push_str(&keyboard_event.key());

    unsafe {
      console_log!("key event, {}", event_string);
    }
  });

  // listen forever
  on_keyup.forget();

  // run the game cycle
  cpu.step_run(move |cpu| {
    unsafe {
      console_log!("Running inside {}", canvas_id);
    }

    if read_screen_state(cpu, &mut screen_state) {
      // map screen_state to cscr
      render_screen(&mut rc, &mut screen_state)
    }

    // ::std::thread::sleep(std::time::Duration::new(0, 70_000));
    // ::std::thread::sleep(std::time::Duration::new(0, 70_000));
    // sleep(Duration::new(0, 70_000));
  });
  Ok(())
}

pub mod color;
pub mod nes;
